--------------------------------------------------
- Utilisation de deux Stack dans la classe Controller
--------------------------------------------------

Les consignes du laboratoire indiquait que les différentes manipulations faites sur une perspective devaient pouvoir être annulées. Nous avons délégués cette responsabilité à la classe "Controller" qui devait donc concerver un historique des commandes effectuées et offrir le moyen de les annuler. De plus, la conception des commandes nous permettait d'offrir très façilement la fonctionnalité de refaire une commande ayant été annulée.

La classe "Controller" devait donc concerver deux informations distinctes : les commandes passées (pouvant être annulées) et les commandes futures (pouvant être refaites). Pour ce faire, nous avons envisagés deux solutions : concerver les deux types de commandes dans le même conteneur ou bien les séparer dans deux conteneurs différents. Dans les deux cas, le conteneur utilisé devrait offrir un accès de type LILO (Last In Last Out).

La première solution aurait pu consiter à utiliser un seule conteneur. Les nouvelles commandes auraient été ajoutées à la fin de la séquence et un index (itérateur ou indice entier) aurait permit de connaître la position de la dernière commande exécutée. Pour annuler une commande, il aurait suffit d'annuler la commande correspondant à l'index sauvegardé et déplacer cet index d'une position vers le début de la séquence. Toute commande se trouvant après cet index conrespondant désormait à des commandes pouvant être refaites. Pour les refaires, il aurait suffit de déplacer l'index d'une position vers la fin de la séquence et d'exécuter la commande trouvée. Dans les deux cas, annuler ou réexécuter, il aurait fallut s'assurer de ne jamais déplacer l'index à l'extérieur de l'interval valide de la séquence. Aussi, dès qu'une nouvelle commande aurait été ajoutée, il aurait fallut disposer des commandes pouvant être refaites.

La seconde solution est celle que nous avons utilisés. Elle consiste à utiliser deux conteneurs, l'un contenant les commandes pouvant être annulées et l'autre contenant les commandes pouvant être réexécutées. Lorsqu'une nouvelle commande est entrée, elle est ajoutée dans la pile des commandes passées et la pile des commandes futures (pouvant être refaites) est vidée. Lorsque l'utilisateur souhaite annuler une commande, il suffit d'annuler la commande se trouvant sur le haut de la pile des commande passées et de la transférer dans la pile des commandes futures. Pour refaire une commande, il suffit d'exécuter la commande se trouvant sur la pile des commande futures et de la déplacer dans la pile des commandes passées.

Bien que nous ayons utilisés la seconde solution, les deux auraient pu être utilisées. Si la seconde solution nous semble plus simple, des tests pourraient révéler que la premières solution soit plus performante.
